%% Instrument Library (transport-agnostic)

%% Add Quantum Design Dynacool (PPMS)  [unchanged: driver uses 'None']
if isfield(Inst_CFG,'PPMS') && isfield(Inst_CFG.PPMS,'enable') && ~isempty(Inst_CFG.PPMS.enable) && Inst_CFG.PPMS.enable
    try
        PPMS_Initial
        ind = smloadinst('PPMS', [], 'None');
        smdata.inst(ind).name = 'PPMS';
        smaddchannel('PPMS','Temp','T',[1.6,300,Inf,1]); 
        smaddchannel('PPMS','TRate','TRate',[0,100,Inf,1]); 
        smaddchannel('PPMS','Field','B',[-9,9,Inf,1E4]); 
        smaddchannel('PPMS','BRate','BRate',[0,0.5,Inf,1E4]);
    catch err
        fprintf(['*ERROR* problem with connecting to Quantum Design Dynacool\n' err.identifier ': ' err.message '\n'])
    end
end

%% Add OI_Triton_Elsa_Control (TCP/USB/GPIB/Serial via cfg)
if isfield(Inst_CFG,'OITriton') && has_transport_fields(Inst_CFG.OITriton)
    try
        [ind, how] = smloadinst_by_cfg('OITriton', Inst_CFG.OITriton, Inst_CFG.GPIB);
        smdata.inst(ind).name = 'ELSA';
        smopen(ind);
        fprintf('[OITriton] Connected via %s\n', how);

        smaddchannel('ELSA','Magnet','Magnet',[0,500,Inf,1]);
        smaddchannel('ELSA','RampRate','Tramp',[0,10,Inf,1]); 
        smaddchannel('ELSA','SetPnt','Tset',[0,500,Inf,1]); 
        smaddchannel('ELSA','T','T',[0,500,Inf,1]); 
        smaddchannel('ELSA','Range','HRange',[0,10000,Inf,1]);
        smaddchannel('ELSA','MStilHTR','HStill',[0,100000,Inf,1]);
        smaddchannel('ELSA','Turbo1','Turbo1',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to OITriton\n' err.identifier ': ' err.message '\n'])
    end
end

%% Add IPS_Mercury Magnet Control (Serial/TCP/GPIB/USB via cfg)
if isfield(Inst_CFG,'IPS_Mercury') && has_transport_fields(Inst_CFG.IPS_Mercury)
    try
        [ind, how] = smloadinst_by_cfg('IPSM', Inst_CFG.IPS_Mercury, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name = 'IPSM';
        fprintf('[IPSM] Connected via %s\n', how);

        smaddchannel('IPSM','B','B',[-5,5,Inf,1]); 
        smaddchannel('IPSM','Persistent','Persistent',[0,1,Inf,1]);
        smaddchannel('IPSM','RampRate','BRate',[0,0.15,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to IPS Mercury\n' err.identifier ': ' err.message '\n'])
    end
end

%% Add iPS Magnet LabVIEW Control  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'IPSM_LV') && isfield(Inst_CFG.IPSM_LV,'enable') && ~isempty(Inst_CFG.IPSM_LV.enable) && Inst_CFG.IPSM_LV.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        % --- VI paths ---
        viSETB_path = fullfile(baseDir, 'sm','channels','vi','OI_IPSM_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','OI_IPSM_Control_Remote.vi');

        % --- Get VI references & open ---
        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('IPSM_LV', [], 'None');
        smdata.inst(ind).name = 'IPSM_LV';
        smaddchannel('IPSM_LV','Field','B',[-5,5,Inf,1]); 
        smaddchannel('IPSM_LV','Brate','Brate',[0,0.15,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to IPSM Magnet (LV)\n' err.identifier ': ' err.message '\n'])
    end
end

%% Cell6 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'Cell6_MAG_Use') && isfield(Inst_CFG.Cell6_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.Cell6_MAG_Use.enable) && Inst_CFG.Cell6_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','Cell6_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','Cell6_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('Cell6_MAG', [], 'None');
        smdata.inst(ind).name = 'Cell6_MAG';
        smaddchannel('Cell6_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('Cell6_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('Cell6_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('Cell6_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to Cell6 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% Cell9 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'Cell9_MAG_Use') && isfield(Inst_CFG.Cell9_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.Cell9_MAG_Use.enable) && Inst_CFG.Cell9_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','Cell9_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','Cell9_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('Cell9_MAG', [], 'None');
        smdata.inst(ind).name = 'Cell9_MAG';
        smaddchannel('Cell9_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('Cell9_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('Cell9_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('Cell9_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to Cell9 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% Cell12 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'Cell12_MAG_Use') && isfield(Inst_CFG.Cell12_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.Cell12_MAG_Use.enable) && Inst_CFG.Cell12_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','Cell12_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','Cell12_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('Cell12_MAG', [], 'None');
        smdata.inst(ind).name = 'Cell12_MAG';
        smaddchannel('Cell12_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('Cell12_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('Cell12_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('Cell12_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to Cell12 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% Cell15 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'Cell15_MAG_Use') && isfield(Inst_CFG.Cell15_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.Cell15_MAG_Use.enable) && Inst_CFG.Cell15_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','Cell15_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','Cell15_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('Cell15_MAG', [], 'None');
        smdata.inst(ind).name = 'Cell15_MAG';
        smaddchannel('Cell15_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('Cell15_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('Cell15_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('Cell15_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to Cell15 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% SCM1 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'SCM1_MAG_Use') && isfield(Inst_CFG.SCM1_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.SCM1_MAG_Use.enable) && Inst_CFG.SCM1_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','SCM1_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','SCM1_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('SCM1_MAG', [], 'None');
        smdata.inst(ind).name = 'SCM1_MAG';
        smaddchannel('SCM1_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('SCM1_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('SCM1_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('SCM1_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to SCM1 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% SCM2 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'SCM2_MAG_Use') && isfield(Inst_CFG.SCM2_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.SCM2_MAG_Use.enable) && Inst_CFG.SCM2_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','SCM2_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','SCM2_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('SCM2_MAG', [], 'None');
        smdata.inst(ind).name = 'SCM2_MAG';
        smaddchannel('SCM2_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('SCM2_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('SCM2_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('SCM2_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to SCM2 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% SCM3 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'SCM3_MAG_Use') && isfield(Inst_CFG.SCM3_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.SCM3_MAG_Use.enable) && Inst_CFG.SCM3_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','SCM3_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','SCM3_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('SCM3_MAG', [], 'None');
        smdata.inst(ind).name = 'SCM3_MAG';
        smaddchannel('SCM3_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('SCM3_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('SCM3_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('SCM3_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to SCM3 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% SCM4 Magnet Control (LabVIEW)  [unchanged: 'None' frontend]
if isfield(Inst_CFG,'SCM4_MAG_Use') && isfield(Inst_CFG.SCM4_MAG_Use,'enable') ...
        && ~isempty(Inst_CFG.SCM4_MAG_Use.enable) && Inst_CFG.SCM4_MAG_Use.enable
    try
        global viSETB; global viGETB;
        mag = actxserver('LabVIEW.Application');
        baseDir = strtrim(userpath);

        viSETB_path = fullfile(baseDir, 'sm','channels','vi','SCM4_MAG_Signaling.vi');
        viGETB_path = fullfile(baseDir, 'sm','channels','vi','SCM4_PS_Control_Remote.vi');

        viSETB = invoke(mag,'GetVIReference', viSETB_path);
        winopen(viSETB_path);

        viGETB = invoke(mag,'GetVIReference', viGETB_path);
        winopen(viGETB_path);

        ind = smloadinst('SCM4_MAG', [], 'None');
        smdata.inst(ind).name = 'SCM4_MAG';
        smaddchannel('SCM4_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('SCM4_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('SCM4_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('SCM4_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* problem with connecting to SCM4 Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% LockIn SR830 (USB/GPIB/TCP/Serial via cfg)
if isfield(Inst_CFG,'SR830_1') && has_transport_fields(Inst_CFG.SR830_1)
    try
        [ind, how] = smloadinst_by_cfg('SR830_Ramp', Inst_CFG.SR830_1, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);

        smdata.inst(ind).name    = 'SR830_1';
        smdata.inst(ind).cntrlfn = @smcSR830_Ramp;
        fprintf('[SR830_1] %s\n', how);

        smaddchannel('SR830_1','X','X',[-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_1','Y','Y',[-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_1','R','R',[-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_1','THETA','Theta',[-180, 180, 1, 1]);
        smaddchannel('SR830_1','FREQ','Freq',[0, 102000, 10, 1]);
        smaddchannel('SR830_1','VREF','Vref',[0.004, 5, 0.001, 1]);
        smaddchannel('SR830_1','IN1','AUX_IN1',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','IN2','AUX_IN2',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','IN3','AUX_IN3',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','IN4','AUX_IN4',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','OUT1','AUX_OUT1',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','OUT2','AUX_OUT2',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','OUT3','AUX_OUT3',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','OUT4','AUX_OUT4',[-10, 10, 0.001, 1]);
        smaddchannel('SR830_1','SENS','Sensitivity',[2e-9, 1, Inf, 1]);
        smaddchannel('SR830_1','TAU','TimeConst',[10e-6, 3e4, Inf, 1]);
        smaddchannel('SR830_1','SYNC','Sync',[0,1,1,1]);
        smaddchannel('SR830_1','DATA1','X-buf');
        smaddchannel('SR830_1','DATA2','Phase-buf');
    catch err
        fprintf(['*ERROR* SR830: ' err.identifier ': ' err.message '\n']);
    end
end

%% SR860 (via cfg)  — set Inst_CFG.SR860_1.<transport>
if isfield(Inst_CFG,'SR860_1') && has_transport_fields(Inst_CFG.SR860_1)
    try
        [ind, how] = smloadinst_by_cfg('SR860', Inst_CFG.SR860_1, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);
        smdata.inst(ind).name    = 'SR860_1';
        smdata.inst(ind).cntrlfn = @smcSR860;
        fprintf('[SR860_1] %s\n', how);

        smaddchannel('SR860_1', 'X', 'Vxx1', [-Inf, Inf, Inf, 100]);
        smaddchannel('SR860_1', 'Y', 'Vxx1_y', [-Inf, Inf, Inf, 100]);
    catch err
        fprintf(['*ERROR* problem with connecting to LockIn SR860\n' err.identifier ': ' err.message '\n'])
    end
end

%% SR865A (via cfg) — set Inst_CFG.SR865A_1.<transport>
if isfield(Inst_CFG,'SR865A_1') && has_transport_fields(Inst_CFG.SR865A_1)
    try
        [ind, how] = smloadinst_by_cfg('SR865A', Inst_CFG.SR865A_1, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name    = 'SR865A_1';
        smdata.inst(ind).cntrlfn = @smcSR865A;
        fprintf('[SR865A_1] %s\n', how);

        smaddchannel('SR865A_1', 'X', 'Vxx', [-Inf, Inf, Inf, 100]);
        smaddchannel('SR865A_1', 'Y', 'Vxy', [-Inf, Inf, Inf, 100]);
    catch err
        fprintf(['*ERROR* problem with connecting to LockIn SR865A\n' err.identifier ': ' err.message '\n'])
    end
end

%% Harvard BabyDAC (BabyDAC)  — Serial/TCP/GPIB/USB via cfg
if isfield(Inst_CFG,'DAC') && has_transport_fields(Inst_CFG.DAC)
    try
        [ind, how] = smloadinst_by_cfg('BabyDAC', Inst_CFG.DAC, Inst_CFG.GPIB);
        % If Serial, you can still tweak properties:
        if strncmpi(how,'Serial',6)
            try, set(smdata.inst(ind).data.inst,'BaudRate',9600); end
            try, set(smdata.inst(ind).data.inst,'timeout',20);   end
        end
        smopen(ind);
        smdata.inst(ind).name = 'DAC';
        fprintf('[BabyDAC] %s\n', how);

        smaddchannel('DAC', 'CH0', 'bg', [-10 10 10 1]);
        smaddchannel('DAC', 'CH1', 'tg', [-3 3 10 1]);

        while smdata.inst(ind).data.inst.BytesAvailable > 0
            fscanf(smdata.inst(ind).data.inst);
            pause(0.3);
        end
        for i=0:3
            stri = num2str(i);
            query(smdata.inst(ind).data.inst,['B0;M2;C' stri ';S0;']);
            query(smdata.inst(ind).data.inst,['B0;M2;C' stri ';U65535;']);
            query(smdata.inst(ind).data.inst,['B0;M2;C' stri ';L0;']);
            dac_zero=32768;
            bit_str=sprintf(['B0;M2;C' stri ';D%.0f;'],dac_zero);
            query(smdata.inst(ind).data.inst,bit_str);
        end
        smdata.inst(ind).data.rng = repmat([-10 10],12,1);
    catch err
        fprintf(['*ERROR* problem with connecting to the DAC\n' err.identifier ': ' err.message '\n'])
    end
end

%% Keithley 2001 (DMM) — transport via cfg
if isfield(Inst_CFG,'K2001') && has_transport_fields(Inst_CFG.K2001)
    try
        [ind_sr, how] = smloadinst_by_cfg('sminst_k2001', Inst_CFG.K2001, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind_sr).data.inst, how);
        smopen(ind_sr);
        smdata.inst(ind_sr).name    = 'k2001';
        smdata.inst(ind_sr).cntrlfn = @smck2001_Ramp;
        fprintf('[K2001] %s\n', how);
        
        smaddchannel('k2001','V','V');
        smaddchannel('k2001','I','I');
        smaddchannel('k2001','V-buf','V-buf');
        smaddchannel('k2001','I-buf','I-buf');
    catch err
        fprintf(['*ERROR* k2001: ' err.identifier ': ' err.message '\n']);
    end
end

%% Keithley 2400 — transport via cfg
if isfield(Inst_CFG,'K2400') && has_transport_fields(Inst_CFG.K2400)
    try
        [ind, how] = smloadinst_by_cfg('K2400_Ramp', Inst_CFG.K2400, Inst_CFG.GPIB);
        smdata.inst(ind).cntrlfn = @smcK2400_Ramp;

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name = 'Source1';
        fprintf('[K2400] %s\n', how);

        % Use instrument name 'Source1' consistently
        smaddchannel('Source1','V','K2400_V',[-20, 20, 1e-3, 1]);
        smaddchannel('Source1','I','K2400_I',[-1, 1, 1e-6, 1]);
        smaddchannel('Source1','Vcompl','K2400_Vcomp',[0,100,1e-2,1]);
        smaddchannel('Source1','Icompl','K2400_Icomp',[0,1,1e-6,1]);
        smaddchannel('Source1','I-buf','Ig-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');
        if isfield(Inst_CFG,'K2400') && isfield(Inst_CFG.K2400,'mode') && strcmpi(Inst_CFG.K2400.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode volt');
            fprintf(smdata.inst(ind).data.inst,':sense:current:range 1e-6');
            fprintf(smdata.inst(ind).data.inst,':sense:current:protection 1e-6');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG,'K2400') && isfield(Inst_CFG.K2400,'mode') && strcmpi(Inst_CFG.K2400.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode curr');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:protection 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:current:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end
        fprintf(smdata.inst(ind).data.inst,':output on');
    catch err
        fprintf(['*ERROR* problem with connecting to the K2400 Source\n' err.identifier ': ' err.message '\n'])
    end
end

%% Keithley 2450 — transport via cfg
if isfield(Inst_CFG,'K2450') && has_transport_fields(Inst_CFG.K2450)
    try
        [ind, how] = smloadinst_by_cfg('K2450_Ramp', Inst_CFG.K2450, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2450';
        smdata.inst(ind).cntrlfn = @smcK2450_Ramp;
        fprintf('[K2450] %s\n', how);

        smaddchannel('K2450','Vg','Vg',[-200, 200, 1e-3, 1]);
        smaddchannel('K2450','Ig','Ig',[-1, 1, 1e-6, 1]);
        smaddchannel('K2450','VgRange','VgRange',[0,5,1,1]);
        smaddchannel('K2450','VgRead','Vg_readback',[-200,200,1e-3,1]);
        smaddchannel('K2450','IgLimit','Ig_limit',[1e-10, 1e-3, 1e-9, 1]);
        smaddchannel('K2450','Vg-ramp','Vg_ramp_rate',[5.5,65.345,0.1,1]);
        smaddchannel('K2450','Ig-buf','Ig-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'*cls');

        if isfield(Inst_CFG,'K2450') && isfield(Inst_CFG.K2450,'mode') && strcmpi(Inst_CFG.K2450.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion VOLTage');
            fprintf(smdata.inst(ind).data.inst,':SENSe:CURRent:RANGe 1e-6');
            fprintf(smdata.inst(ind).data.inst,':SOURce:VOLTage:ILIMit 1e-7');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG,'K2450') && isfield(Inst_CFG.K2450,'mode') && strcmpi(Inst_CFG.K2450.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion CURRent');
            fprintf(smdata.inst(ind).data.inst,':SOURce:CURRent:VLIMit 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end
    
        fprintf(smdata.inst(ind).data.inst,':output on');
        fprintf(smdata.inst(ind).data.inst,':count 1;:trig:cont rest');
    catch err
        fprintf(['*ERROR* problem with connecting to the K2450 Source | ' err.identifier ': ' err.message '\n']);
    end
end

%% Keithley 2700 — transport via cfg
if isfield(Inst_CFG,'K2700') && has_transport_fields(Inst_CFG.K2700)
    try
        [ind, how] = smloadinst_by_cfg('K2700', Inst_CFG.K2700, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        set(smdata.inst(ind).data.inst,'timeout',30);

        smopen(ind);

        smdata.inst(ind).name = 'DMM';
        fprintf('[K2700] %s\n', how);

        smaddchannel('DMM','V','Vdc',[-Inf Inf Inf 100]);
        smaddchannel('DMM','V','Idc_m',[-Inf Inf Inf -1e6]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'initiate:continuous on;:abort');
        fprintf(smdata.inst(ind).data.inst,':voltage:nplcycles 1');
        fprintf(smdata.inst(ind).data.inst,'sense:voltage:dc:average:state off');
        fprintf(smdata.inst(ind).data.inst,':sense:voltage:range:auto 1');
    catch err
        fprintf(['*ERROR* problem with connecting to the K2700 DMM\n' err.identifier ': ' err.message '\n'])
    end
end

%% Keysight 33511B (Function Gen) — transport via cfg
if isfield(Inst_CFG,'KS33511B') && has_transport_fields(Inst_CFG.KS33511B)
    try
        [ind, how] = smloadinst_by_cfg('KS33511B', Inst_CFG.KS33511B, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name = 'FunGen';
        fprintf('[KS33511B] %s\n', how);

        smaddchannel('FunGen','Vac','Vac',[-10 10 1 1]);
        smaddchannel('FunGen','Vdc','Vdc',[-10 10 1 1]);
        smaddchannel('FunGen','Freq','Freq',[0 2e7 Inf 1]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'*cls');
        fprintf(smdata.inst(ind).data.inst,'OUTP:LOAD INF');
        fprintf(smdata.inst(ind).data.inst,'SOUR:FUNC SIN');
        fprintf(smdata.inst(ind).data.inst,'SOUR:VOLT:UNIT VRMS');
        fprintf(smdata.inst(ind).data.inst,'SOUR:VOLT 1E-3');
        fprintf(smdata.inst(ind).data.inst,'SOUR:FREQ 23.33');
        fprintf(smdata.inst(ind).data.inst,'OUTP ON');
    catch err
        fprintf(['*ERROR* problem with connecting to the Function Generator\n' err.identifier ': ' err.message '\n'])
    end
end

%% Keysight 34465A (DMM, VISA/USB or other via cfg)
if isfield(Inst_CFG,'KS34465A_1') && has_transport_fields(Inst_CFG.KS34465A_1)
    try
        [ind, how] = smloadinst_by_cfg('KS34465A', Inst_CFG.KS34465A_1, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        set(smdata.inst(ind).data.inst,'timeout',10);

        smopen(ind);

        smdata.inst(ind).name = 'DMM';
        fprintf('[KS34465A_1] %s\n', how);

        % Use instrument name 'DMM' consistently
        smaddchannel('DMM','VAL','Vdc_Read',[-Inf Inf Inf 1]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'*cls');
        if isfield(Inst_CFG.KS34465A_1,'mode') && strcmpi(Inst_CFG.KS34465A_1.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,'configure:volt:dc');
            fprintf(smdata.inst(ind).data.inst,'sense:voltage:nplc 1');
        elseif isfield(Inst_CFG.KS34465A_1,'mode') && strcmpi(Inst_CFG.KS34465A_1.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,'configure:curr:dc');
            fprintf(smdata.inst(ind).data.inst,'sense:curr:nplc 1');
        end
        fprintf(smdata.inst(ind).data.inst,'trig:count inf');
        fprintf(smdata.inst(ind).data.inst,'init');
    catch err
        fprintf(['*ERROR* problem with connecting to the Keysight DMM\n' err.identifier ': ' err.message '\n'])
    end
end

%% Keysight B2902A (SourceMeter) — transport via cfg
if isfield(Inst_CFG,'SourceMeter') && has_transport_fields(Inst_CFG.SourceMeter)
    try
        [ind, how] = smloadinst_by_cfg('B2902A', Inst_CFG.SourceMeter, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        set(smdata.inst(ind).data.inst,'timeout',5);

        smopen(ind);

        smdata.inst(ind).name = 'SourceMeter';
        fprintf('[B2902A] %s\n', how);

        smaddchannel('SourceMeter','V1','Vg',[-10 12 20 1]);
        smaddchannel('SourceMeter','V2','Ib',[-1e-7 1e-7 20 1e8]);
        smaddchannel('SourceMeter','V2','Vbias2',[-10e-3 10e-3 20 1000]);
        smaddchannel('SourceMeter','I1','Ig',[-1 1 Inf 1]); 
        smaddchannel('SourceMeter','I2','Ibias2',[-1 1 Inf 1]);
        smaddchannel('SourceMeter','Icompl1','Ic1',[0 1 Inf 1]);
        smaddchannel('SourceMeter','Icompl2','Ic2',[0 1 Inf 1]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        if isfield(Inst_CFG,'mode') && isfield(Inst_CFG.mode,'SourceMeter_CH1')
            if strcmpi(Inst_CFG.mode.SourceMeter_CH1,'Voltage')
                fprintf(smdata.inst(ind).data.inst,':sense1:current:protection 1e-8');
                fprintf(smdata.inst(ind).data.inst,':sense1:current:range:auto 1');
            elseif strcmpi(Inst_CFG.mode.SourceMeter_CH1,'Current')
                fprintf(smdata.inst(ind).data.inst,':source1:function:mode current');
                fprintf(smdata.inst(ind).data.inst,':sense1:voltage:protection 1');
                fprintf(smdata.inst(ind).data.inst,':sense1:voltage:range:auto 1');
            else
                error('No such mode for SourceMeter CH1: %s', Inst_CFG.mode.SourceMeter_CH1);
            end
        end
        fprintf(smdata.inst(ind).data.inst,':output1 on');
        fprintf(smdata.inst(ind).data.inst,':arm1:acq:count infinity');
        fprintf(smdata.inst(ind).data.inst,':init:acq (@1)');
        
        if isfield(Inst_CFG,'mode') && isfield(Inst_CFG.mode,'SourceMeter_CH2')
            if strcmpi(Inst_CFG.mode.SourceMeter_CH2,'Voltage')
                fprintf(smdata.inst(ind).data.inst,':sense2:current:protection 1e-8');
                fprintf(smdata.inst(ind).data.inst,':sense2:current:range:auto 1');
            elseif strcmpi(Inst_CFG.mode.SourceMeter_CH2,'Current')
                fprintf(smdata.inst(ind).data.inst,':source2:function:mode current');
                fprintf(smdata.inst(ind).data.inst,':sense2:voltage:protection 1');
                fprintf(smdata.inst(ind).data.inst,':sense2:voltage:range:auto 1');
            else
                error('No such mode for SourceMeter CH2: %s', Inst_CFG.mode.SourceMeter_CH2);
            end
        end
        fprintf(smdata.inst(ind).data.inst,':output2 on');
        fprintf(smdata.inst(ind).data.inst,':arm2:acq:count infinity');
        fprintf(smdata.inst(ind).data.inst,':init:acq (@2)');
    catch err
        fprintf(['*ERROR* problem with connecting to the SourceMeter\n' err.identifier ': ' err.message '\n'])
    end
end

%% Z Magnet (CryoLtd) — transport via cfg
if isfield(Inst_CFG,'Magnet') && has_transport_fields(Inst_CFG.Magnet)
    try
        [ind, how] = smloadinst_by_cfg('CryoLtd', Inst_CFG.Magnet, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name = 'Magnet';
        fprintf('[Magnet CryoLtd] %s\n', how);
        
        smaddchannel('Magnet','I','B',[-9,9,Inf,10.167]);   % Ramping auto
        smaddchannel('Magnet','M','Bmax',[0,1,Inf,10.167]); % Max field
    catch err
        fprintf(['*ERROR* problem with connecting to the Magnet\n' err.identifier ': ' err.message '\n'])
    end
end

%% Current source MagnetK2400 for small B field — transport via cfg
if isfield(Inst_CFG,'MagnetK2400') && has_transport_fields(Inst_CFG.MagnetK2400)
    try
        [ind, how] = smloadinst_by_cfg('K2400', Inst_CFG.MagnetK2400, Inst_CFG.GPIB);

        % GPIB-only buffers/EOS
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name = 'MagnetSource';
        fprintf('[MagnetSource K2400] %s\n', how);
  
        fprintf(smdata.inst(ind).data.inst,'*RST');
        fprintf(smdata.inst(ind).data.inst,':sour:func curr');
        fprintf(smdata.inst(ind).data.inst,':sens:func "volt"');
        fprintf(smdata.inst(ind).data.inst,':outp on');
    
        smaddchannel('MagnetSource','V','VB',[-Inf Inf Inf 1]); % read-only
        smaddchannel('MagnetSource','I','Bi',[-0.1032,0.1032, 0.0005, 9.6899]);
        smget('VB')
    catch err
        fprintf(['*ERROR* problem with connecting to the MagnetSource (K2400)\n' err.identifier ': ' err.message '\n'])
    end   
end

%% Current source (B2902A as magnet source) — transport via cfg
if isfield(Inst_CFG,'MagnetSource') && has_transport_fields(Inst_CFG.MagnetSource)
    try
        [ind, how] = smloadinst_by_cfg('B2902A', Inst_CFG.MagnetSource, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name    = 'MagnetSource';
        smdata.inst(ind).cntrlfn = @smcB2902A_Alt;
        fprintf('[MagnetSource B2902A] %s\n', how);
        
        smaddchannel('MagnetSource','V1','VB',[-Inf Inf Inf 1]); % read-only
        smaddchannel('MagnetSource','I1','Bi',[-0.4,0.4, 0.002, 1/0.1336]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,':source1:function:mode current');
        fprintf(smdata.inst(ind).data.inst,':sense1:voltage:protection 2');
        fprintf(smdata.inst(ind).data.inst,':sense1:voltage:range:auto 2');
        fprintf(smdata.inst(ind).data.inst,':output1 on');
        smget('VB')
    catch err
        fprintf(['*ERROR* problem with connecting to the MagnetSource (B2902A)\n' err.identifier ': ' err.message '\n'])
    end
end

%% AVS47B AC resistance bridge for thermometry — transport via cfg
if isfield(Inst_CFG,'AVS47B') && has_transport_fields(Inst_CFG.AVS47B)
    try
        [ind, how] = smloadinst_by_cfg('AVS47B_GPIB', Inst_CFG.AVS47B, Inst_CFG.GPIB);
        smdata.inst(ind).name = 'AVS47B';
        smopen(ind);
        fprintf('[AVS47B] %s\n', how);
        
        smdata.inst(ind).data.calibration{1} = 'RuO2 10k';
        smdata.inst(ind).data.calibration{2} = 'RuO2 10k';
        smdata.inst(ind).data.calibration{3} = 'TT-1306';
        smdata.inst(ind).data.calibration{4} = 'RuO2 1k5';
        smdata.inst(ind).data.calibration{5} = 'RuO2 10k';
        smdata.inst(ind).data.calibration{6} = 'PT1000';
        
        smdata.inst(ind).data.excitation(1) = 4;
        smdata.inst(ind).data.excitation(2) = 4;
        smdata.inst(ind).data.excitation(3) = 3;
        smdata.inst(ind).data.excitation(4) = 3;
        smdata.inst(ind).data.excitation(5) = 3;
        smdata.inst(ind).data.excitation(6) = 3;
                
        smaddchannel('AVS47B', 'CH1', 'T_sorp',   [-Inf, Inf, Inf, 1e3]);
        smaddchannel('AVS47B', 'CH2', 'T_still',  [-Inf, Inf, Inf, 1e3]);
        smaddchannel('AVS47B', 'CH3', 'T_MCLow',  [-Inf, Inf, Inf, 1e3]);
        smaddchannel('AVS47B', 'CH4', 'T_50mK',   [-Inf, Inf, Inf, 1e3]);
        smaddchannel('AVS47B', 'CH5', 'T_Magnet', [-Inf, Inf, Inf, 1e3]);
        smaddchannel('AVS47B', 'CH6', 'T_MCHigh', [-Inf, Inf, Inf, 1]);
    catch err
        fprintf(['*ERROR* problem with connecting to AVS47B\n' err.identifier ': ' err.message '\n'])
    end
end

%% Triple Current Source for heating (TCS) — transport via cfg
if isfield(Inst_CFG,'TCS') && has_transport_fields(Inst_CFG.TCS)
    try
        [ind, how] = smloadinst_by_cfg('TCS', Inst_CFG.TCS, Inst_CFG.GPIB);
        smdata.inst(ind).name = 'TCS';
        smopen(ind);
        fprintf('[TCS] %s\n', how);
        
        smaddchannel('TCS', 'SRC1', 'I_sorp',   [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS', 'SRC1', 'I_switch', [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS', 'SRC2', 'I_still',  [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS', 'SRC3', 'I_mc',     [-Inf, Inf, Inf, 1]);
    catch err
        fprintf(['*ERROR* problem with connecting to TCS\n' err.identifier ': ' err.message '\n'])
    end
end


%% ===================== Helper functions =====================

function tf = has_transport_fields(cfg)
    if isempty(cfg) || ~isstruct(cfg), tf = false; return; end
    tf = false;
    if (isfield(cfg,'usb') && ~isempty(cfg.usb)) || (isfield(cfg,'Usb') && ~isempty(cfg.Usb)) || ...
       (isfield(cfg,'visa') && ~isempty(cfg.visa)) || (isfield(cfg,'Visa') && ~isempty(cfg.Visa)) || ...
       (isfield(cfg,'resource') && ~isempty(cfg.resource)) || (isfield(cfg,'Resource') && ~isempty(cfg.Resource))
        tf = true; return;
    end
    if (isfield(cfg,'gpib_addr') && ~isempty(cfg.gpib_addr)) || (isfield(cfg,'Gpib') && ~isempty(cfg.Gpib))
        tf = true; return;
    end
    if (isfield(cfg,'tcp') && ~isempty(cfg.tcp)) || (isfield(cfg,'Tcp') && ~isempty(cfg.Tcp))
        tf = true; return;
    end
    if (isfield(cfg,'serial') && ~isempty(cfg.serial)) || (isfield(cfg,'Serial') && ~isempty(cfg.Serial)) || ...
       (isfield(cfg,'Com') && ~isempty(cfg.Com))
        tf = true; return;
    end
    % .enable alone doesn't define a transport
end

function [ind, via] = smloadinst_by_cfg(driverName, cfg, gpibCfg)
% smloadinst_by_cfg  (patched)
% Choose transport strictly from fields in cfg, rewrite the saved
% sminst_<driverName> constructor.fn/args to match that transport,
% then call smloadinst with the correct signature.
%
% Priority: USB/VISA -> GPIB -> TCP -> Serial
%
% cfg supports: Usb/usb/Visa/visa/Resource/resource, Gpib/gpib_addr,
%               Tcp/Port, Serial/Com, optional .enable

    if nargin < 3 || isempty(gpibCfg)
        gpibCfg.board = 'ni';
        gpibCfg.index = 0;
    end

    ind = []; via = '';

    % Respect optional enable gate
    if isfield(cfg,'enable') && ~isempty(cfg.enable) && ~logical(cfg.enable)
        via = 'disabled';
        error('smloadinst_by_cfg:Disabled','Instrument disabled by cfg.enable=false.');
    end

    % -------- VISA / USBTMC (preferred when present) --------
    if hasval(cfg,'usb') || hasval(cfg,'Usb') || hasval(cfg,'visa') || hasval(cfg,'Visa') || hasval(cfg,'resource') || hasval(cfg,'Resource')
        rn = firstval(cfg, {'usb','Usb','visa','Visa','resource','Resource'});
        % Patch sminst to VISA beforehand
        patchedFile = patch_sminst(driverName, 'visa', {rn});
        vendor = pick_visa_vendor(); % 'keysight' | 'agilent' | 'ni'
        ind = smloadinst(patchedFile, [], vendor, rn);
        via = sprintf('VISA (%s)', rn);
        return
    end

    % -------- GPIB --------
    if hasval(cfg,'gpib_addr') || hasval(cfg,'Gpib')
        addr  = [];
        board = gpibCfg.board;
        index = gpibCfg.index;

        if hasval(cfg,'gpib_addr'), addr = cfg.gpib_addr; end
        if hasval(cfg,'Gpib')
            if isstruct(cfg.Gpib)
                if hasval(cfg.Gpib,'board'), board = cfg.Gpib.board; end
                if hasval(cfg.Gpib,'index'), index = cfg.Gpib.index; end
                if hasval(cfg.Gpib,'addr'),  addr  = cfg.Gpib.addr;  end
            else
                addr = cfg.Gpib;
            end
        end

        % Patch sminst to GPIB beforehand
        patchedFile = patch_sminst(driverName, 'gpib', {index, addr});
        ind = smloadinst(patchedFile, [], board, index, addr);
        via = sprintf('GPIB (%s,%d,%s)', char(string(board)), index, char(string(addr)));
        return
    end

    % -------- TCP (RAW socket, e.g. :5025) --------
    if hasval(cfg,'tcp') || hasval(cfg,'Tcp')
        hp = '';
        if hasval(cfg,'tcp'), hp = cfg.tcp; end
        if hasval(cfg,'Tcp'), hp = cfg.Tcp; end
        if isfield(cfg,'Port') && ~contains(string(hp),':') && ~isempty(cfg.Port)
            hp = sprintf('%s:%d', char(string(hp)), cfg.Port);
        end

        % Patch sminst to tcpclient beforehand
        patchedFile = patch_sminst(driverName, 'tcpclient', {hp});
        ind = smloadinst(patchedFile, [], 'tcpclient', char(string(hp)));
        via = sprintf('TCP (%s)', char(string(hp)));
        return
    end

    % -------- Serial (COMx) --------
    if hasval(cfg,'serial') || hasval(cfg,'Serial') || hasval(cfg,'Com')
        com = '';
        if hasval(cfg,'serial'), com = cfg.serial; end
        if hasval(cfg,'Serial'), com = cfg.Serial; end
        if hasval(cfg,'Com'),    com = cfg.Com;    end
        if isnumeric(com)
            com = sprintf('COM%d', com);
        else
            s = string(com);
            if ~startsWith(upper(s),'COM'), com = char("COM" + s); else, com = char(s); end
        end

        % Patch sminst to serial beforehand
        patchedFile = patch_sminst(driverName, 'serial', {com});
        ind = smloadinst(patchedFile, [], 'serial', com);
        via = sprintf('Serial (%s)', com);
        return
    end

    % -------- Nothing matched --------
    error('smloadinst_by_cfg:NoTransport', ...
          'No transport for "%s". Set one of Usb/Visa/resource, Gpib/gpib_addr, Tcp(+Port), or Serial/Com.', driverName);

% ==== helpers ====

    function tf = hasval(s, f)
        tf = isfield(s,f) && ~isempty(s.(f));
    end

    function v = firstval(s, keys)
        v = '';
        for k = 1:numel(keys)
            if isfield(s, keys{k}) && ~isempty(s.(keys{k}))
                v = s.(keys{k});
                return
            end
        end
    end

    function vendor = pick_visa_vendor()
        % Choose an installed VISA adaptor (order preference).
        vendor = 'ni';
        try
            info = instrhwinfo('visa'); % deprecated but often available
            prefs = {'keysight','agilent','ni'};
            for i = 1:numel(prefs)
                if any(strcmpi(info.InstalledAdaptors, prefs{i}))
                    vendor = prefs{i}; break
                end
            end
        catch
            % keep 'ni'
        end
    end

    function patchedPath = patch_sminst(name, kind, argsCell)
        % Load sminst_<name>, rewrite constructor.fn/args, save as
        % a temp "sminst_patched_<name>.mat" and return that path.
        % kind in {'visa','gpib','serial','tcpclient'}

        % Locate the original
        cand = {['sminst_', name], ['sminst_', name, '.mat']};
        orig = '';
        for c = 1:numel(cand)
            p = which(cand{c});
            if ~isempty(p), orig = p; break, end
        end
        if isempty(orig)
            % Fall back: smloadinst will try to resolve; but we cannot patch.
            patchedPath = ['sminst_', name];
            warning('patch_sminst:NotFound', 'Could not find sminst_%s on path; proceeding without patch.', name);
            return
        end

        S = load(orig);  % must contain S.constructor and S.inst

        % Rewrite constructor.fn and args
        switch lower(kind)
            case 'visa'
                S.constructor.fn   = @visa;       % legacy VISA object (vendor passed via smloadinst)
                S.constructor.args = argsCell;    % {'USB0::...::INSTR'}

            case 'gpib'
                S.constructor.fn   = @gpib;       % vendor passed via smloadinst
                S.constructor.args = argsCell;    % {index, addr}

            case 'serial'
                S.constructor.fn   = @serial;
                S.constructor.args = argsCell;    % {'COMx'}

            case 'tcpclient'
                S.constructor.fn   = @tcpclient;
                S.constructor.args = argsCell;    % {'host:port'}

            otherwise
                error('patch_sminst:UnknownKind','Unknown kind "%s".', kind);
        end

        % Save patched copy (temp dir, but name must contain 'sminst_')
        patchedPath = fullfile(tempdir, ['sminst_patched_', name, '.mat']);
        save(patchedPath, '-struct', 'S');
    end
end

function apply_gpib_buffers(obj, via)
% Apply buffer sizes and EOS only when transport is GPIB.
% Safe to call before/after smopen. Guards against missing props.
    if strncmpi(via, 'GPIB', 4)
        try, set(obj, 'inputbuffersize',  2^18); end   % ~262 kB
        try, set(obj, 'outputbuffersize', 2^10); end   % 1 kB
        if isprop(obj, 'EOSMode')
            try, set(obj, 'eosmode', 'read&write'); end
        end
    end
end
