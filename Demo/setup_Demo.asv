%================= Vector Setup Instrument Initialization =================
% Clear out Matlab
clear all;
close all;
instrreset;
format long
%--------------------- User data directory ---------------------
filedirectory = 'C:\Users\WangLabAdmin\Desktop\test';

%%%%=================== Unified configuration ===================
Inst_CFG = struct();

% ------------------- Bus / transport configs -------------------
% GPIB controller settings (default if you use .Gpib = <addr>)
Inst_CFG.GPIB.board = 'ni';
Inst_CFG.GPIB.index = 0;

% ------------------- Instrument-centric configs ----------------
% Use ONE transport per instrument: .Usb/.Visa/.Resource, or .Gpib (number or struct), or .Tcp(+.Port), or .Serial/.Com

%% Fridge Connection

% PPMS
% Inst_CFG.PPMS.enable            = true;

% Maglab SCM1
% Inst_CFG.SCM1_MAG_Use.enable  = true;

% Maglab Cell12
% Inst_CFG.Cell12_MAG_Use.enable  = true;

% OI Triton (TCP)
Inst_CFG.OITriton.Tcp = 'mrl-dvh-elsa.mrl.illinois.edu:33576';  % 'host:port'

% Oxford IPS Mercury (LabVIEW)
Inst_CFG.IPSM_LV.enable         = true;

% Oxford IPS Mercury (Serial)
% Inst_CFG.IPS_Mercury.Serial = 'COM3';


%% Electronics

% Lock-in SR830 family (examples)
Inst_CFG.SR830_1.Gpib = 1;        % e.g. 1   (or .Usb = 'USB0::...::INSTR')
Inst_CFG.SR830_2.Gpib = 2;       % fill to enable
Inst_CFG.SR830_3.Gpib = 3;
Inst_CFG.SR830_4.Gpib = 4;

% SR860 family (optional; comment if unused)
% Inst_CFG.SR860_1.Gpib = 1;

% Keithley 2400 SMUs
Inst_CFG.K2400_1.Gpib = 21; Inst_CFG.K2400_1.mode = 'Voltage';  % 'Voltage' or 'Current'
Inst_CFG.K2400_2.Gpib = 22; Inst_CFG.K2400_2.mode = 'Voltage';
Inst_CFG.K2400_3.Gpib = 23; Inst_CFG.K2400_3.mode = 'Voltage';
Inst_CFG.KS33511B.Gpib = 11;
% Keithley 2450 SMUs (examples)
% Inst_CFG.K2450.Usb   = 'USB0::0x05E6::0x2450::1234567::INSTR';
% Inst_CFG.K2450_2.Tcp = '192.168.1.50:5025';

% Keysight B2902A as magnet source (example)
% Inst_CFG.MagnetSource.Gpib = 25;   % or .Tcp = 'host:5025' or .Usb = 'USB0::...'

% CryoLtd Magnet controller (Serial)
% Inst_CFG.Magnet.Serial = 'COM5';

% Current source K2400 as magnet supply (example)
% Inst_CFG.MagnetK2400.Gpib = 24;



% Triple Current Source (Serial example)
% Inst_CFG.TCS.Serial = 'COM7';

%%%%=================== Load empty smdata shell ==================
global smdata;
global smscan;
load smdata_empty;

%% Add instruments to rack (dummy + basic)
smloadinst('test');
smaddchannel('test', 'CH1', 'dummy');
smaddchannel('test', 'CH2', 'count');

%====================== PPMS (Dynacool) ========================
% (PPMS front-end remains 'None'; its driver handles transport internally)
if isfield(Inst_CFG,'PPMS') && isfield(Inst_CFG.PPMS,'enable') && ~isempty(Inst_CFG.PPMS.enable) && Inst_CFG.PPMS.enable
    try
        PPMS_Initial
        ind = smloadinst('PPMS', [], 'None');
        smdata.inst(ind).name = 'PPMS';
        smaddchannel('PPMS','Temp','T',[1.6,300,Inf,1]);
        smaddchannel('PPMS','Field','B',[-9,9,Inf,1E4]);
    catch err
        fprintf(['*ERROR* PPMS: ' err.identifier ': ' err.message '\n']);
    end
end

%================== OI Triton (TCP/USB/Serial/GPIB via exact smloadinst calls) =====================
if isfield(Inst_CFG,'OITriton') && has_transport_fields(Inst_CFG.OITriton)
    try
        [ind, how] = smloadinst_by_cfg('OITriton', Inst_CFG.OITriton, Inst_CFG.GPIB);
        smdata.inst(ind).name = 'ELSA';
        % (no GPIB-only props needed here)
        smopen(ind);
        fprintf('[OITriton] Connected via %s\n', how);

        smaddchannel('ELSA','Magnet','Magnet',[0,500,Inf,1]);
        smaddchannel('ELSA','RampRate','Tramp',[0,10,Inf,1]);
        smaddchannel('ELSA','SetPnt','Tset',[0,500,Inf,1]);
        smaddchannel('ELSA','T','T',[0,500,Inf,1]);
        smaddchannel('ELSA','Range','HRange',[0,10000,Inf,1]);
        smaddchannel('ELSA','MStilHTR','HStill',[0,100000,Inf,1]);
        smaddchannel('ELSA','Turbo1','Turbo1',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* OITriton: ' err.identifier ': ' err.message '\n']);
    end
end

%================== IPS Mercury (Serial/TCP/etc) =======================
if isfield(Inst_CFG,'IPS_Mercury') && has_transport_fields(Inst_CFG.IPS_Mercury)
    try
        [ind, how] = smloadinst_by_cfg('IPSM', Inst_CFG.IPS_Mercury, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name = 'IPSM';
        fprintf('[IPSM] Connected via %s\n', how);

        smaddchannel('IPSM','B','B',[-5,5,Inf,1]);
        smaddchannel('IPSM','Persistent','Persistent',[0,1,Inf,1]);
        smaddchannel('IPSM','RampRate','BRate',[0,0.15,Inf,1]);
    catch err
        fprintf(['*ERROR* IPS Mercury: ' err.identifier ': ' err.message '\n']);
    end
end

%========== iPS Magnet LabVIEW Control (toggle via .enable) ==========
if isfield(Inst_CFG,'IPSM_LV') && isfield(Inst_CFG.IPSM_LV,'enable') && ~isempty(Inst_CFG.IPSM_LV.enable) && Inst_CFG.IPSM_LV.enable
    try
        global viSETB;
        global viGETB;
        mag = actxserver('LabVIEW.Application');

        baseDir = strtrim(userpath);
        viSETB = invoke(mag,'GetVIReference', fullfile(baseDir,'sm\channels\vi\Triton_Elsa_Signaling.vi'));
        viSETB = invoke(mag,'GetVIReference', fullfile(baseDir,'sm\channels\vi\OI_IPSM_Signaling.vi'));
        !sm\channels\vi\OI_IPSM_Signaling.vi
        viGETB = invoke(mag,'GetVIReference', fullfile(baseDir,'sm\channels\vi\OI_IPSM_Control_Remote.vi'));
        !sm\channels\vi\OI_IPSM_Signaling.vi

        ind = smloadinst('IPSM_LV', [], 'None');
        smdata.inst(ind).name = 'IPSM_LV';
        smaddchannel('IPSM_LV','Field','B',[-5,5,Inf,1]);
        smaddchannel('IPSM_LV','Brate','Brate',[0,0.15,Inf,1]);
    catch err
        fprintf(['*ERROR* IPSM Magnet (LV): ' err.identifier ': ' err.message '\n']);
    end
end

%% Cell12 Magnet Control (LabVIEW)
if isfield(Inst_CFG,'Cell12_MAG_Use') && isfield(Inst_CFG.Cell12_MAG_Use,'enable') && ~isempty(Inst_CFG.Cell12_MAG_Use.enable) && Inst_CFG.Cell12_MAG_Use.enable
    try
        global viSETB;
        global viGETB;
        mag = actxserver('LabVIEW.Application');

        baseDir = strtrim(userpath);
        viSETB = invoke(mag,'GetVIReference', fullfile(baseDir,'sm\channels\vi\Cell12_MAG_Signaling.vi'));
        !sm\channels\vi\Cell12_MAG_Signaling.vi
        viGETB = invoke(mag,'GetVIReference', fullfile(baseDir,'sm\channels\vi\Cell12_PS_Control_Remote.vi'));
        !sm\channels\vi\Cell16_MAG_Signaling.vi

        ind = smloadinst('Cell12_MAG', [], 'None');
        smdata.inst(ind).name = 'Cell12_MAG';
        smaddchannel('Cell12_MAG','Field','B',[-35,35,Inf,1]);
        smaddchannel('Cell12_MAG','Brate','Brate',[0,7,Inf,1]);
        smaddchannel('Cell12_MAG','T','T',[0,20,Inf,1]);
        smaddchannel('Cell12_MAG','Trate','Trate',[0,1,Inf,1]);
    catch err
        fprintf(['*ERROR* Cell12 Magnet: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== SR830_1: LockIn ======================
if isfield(Inst_CFG,'SR830_1') && has_transport_fields(Inst_CFG.SR830_1)
    try
        [ind, how] = smloadinst_by_cfg('SR830_Ramp', Inst_CFG.SR830_1, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);

        smdata.inst(ind).name    = 'SR830_1';
        smdata.inst(ind).cntrlfn = @smcSR830_Ramp;
        fprintf('[SR830_1] %s\n', how);

        smaddchannel('SR830_1','X', 'Isd_1',   [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_1','Y', 'Isd_Y_1', [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_1','OUT1','AUX_OUT1',[-10,10,0.001,1]);
        smaddchannel('SR830_1','DATA1','Iac1-buf_1');
        smaddchannel('SR830_1','DATA2','Iac1-phase-buf_1');
    catch err
        fprintf(['*ERROR* SR830_1: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== SR830_2: LockIn ======================
if isfield(Inst_CFG,'SR830_2') && has_transport_fields(Inst_CFG.SR830_2)
    try
        [ind, how] = smloadinst_by_cfg('SR830_Ramp', Inst_CFG.SR830_2, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);

        smdata.inst(ind).name    = 'SR830_2';
        smdata.inst(ind).cntrlfn = @smcSR830_Ramp;
        fprintf('[SR830_2] %s\n', how);

        smaddchannel('SR830_2','X', 'Isd_2',   [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_2','Y', 'Isd_Y_2', [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_2','DATA1','Iac1-buf_2');
        smaddchannel('SR830_2','DATA2','Iac1-phase-buf_2');
    catch err
        fprintf(['*ERROR* SR830_2: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== SR830_3: LockIn ======================
if isfield(Inst_CFG,'SR830_3') && has_transport_fields(Inst_CFG.SR830_3)
    try
        [ind, how] = smloadinst_by_cfg('SR830_Ramp', Inst_CFG.SR830_3, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);

        smdata.inst(ind).name    = 'SR830_3';
        smdata.inst(ind).cntrlfn = @smcSR830_Ramp;
        fprintf('[SR830_3] %s\n', how);

        smaddchannel('SR830_3','X', 'Isd_3',   [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_3','Y', 'Isd_Y_3', [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_3','DATA1','Iac1-buf_3');
        smaddchannel('SR830_3','DATA2','Iac1-phase-buf_3');
    catch err
        fprintf(['*ERROR* SR830_3: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== SR830_4: LockIn ======================
if isfield(Inst_CFG,'SR830_4') && has_transport_fields(Inst_CFG.SR830_4)
    try
        [ind, how] = smloadinst_by_cfg('SR830_Ramp', Inst_CFG.SR830_4, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);
        smopen(ind);

        smdata.inst(ind).name    = 'SR830_4';
        smdata.inst(ind).cntrlfn = @smcSR830_Ramp;
        fprintf('[SR830_4] %s\n', how);

        smaddchannel('SR830_4','X', 'Isd_4',   [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_4','Y', 'Isd_Y_4', [-Inf, Inf, Inf, 1e6]);
        smaddchannel('SR830_4','DATA1','Iac1-buf_4');
        smaddchannel('SR830_4','DATA2','Iac1-phase-buf_4');
    catch err
        fprintf(['*ERROR* SR830_4: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== Keithley 2400_1 ==========================
if isfield(Inst_CFG,'K2400_1') && has_transport_fields(Inst_CFG.K2400_1)
    try
        [ind, how] = smloadinst_by_cfg('K2400_Ramp', Inst_CFG.K2400_1, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2400_1';
        smdata.inst(ind).cntrlfn = @smcK2400_Ramp;
        fprintf('[K2400_1] %s\n', how);

        % (Optional) safe re-apply (wrapped) in case driver resets on open
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smaddchannel('K2400_1','V',     'V1',     [-10, 10, Inf, 1]);
        smaddchannel('K2400_1','I',     'I1',     [-Inf, Inf, Inf, 1e6]);
        smaddchannel('K2400_1','I-buf', 'I1-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');

        if isfield(Inst_CFG.K2400_1,'mode') && strcmpi(Inst_CFG.K2400_1.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode volt');
            fprintf(smdata.inst(ind).data.inst,':sense:current:range 1e-6');
            fprintf(smdata.inst(ind).data.inst,':sense:current:protection 1e-6');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG.K2400_1,'mode') && strcmpi(Inst_CFG.K2400_1.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode curr');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:protection 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:current:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end
        fprintf(smdata.inst(ind).data.inst,':output on');
    catch err
        fprintf(['*ERROR* K2400_1: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== Keithley 2400_2 ==========================
if isfield(Inst_CFG,'K2400_2') && has_transport_fields(Inst_CFG.K2400_2)
    try
        [ind, how] = smloadinst_by_cfg('K2400_Ramp', Inst_CFG.K2400_2, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2400_2';
        smdata.inst(ind).cntrlfn = @smcK2400_Ramp;
        fprintf('[K2400_2] %s\n', how);

        % Safe re-apply
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smaddchannel('K2400_2','V',     'V2',     [-10, 10, Inf, 1]);
        smaddchannel('K2400_2','I',     'I2',     [-Inf, Inf, Inf, 1e6]);
        smaddchannel('K2400_2','I-buf', 'I2-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');

        if isfield(Inst_CFG.K2400_2,'mode') && strcmpi(Inst_CFG.K2400_2.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode volt');
            fprintf(smdata.inst(ind).data.inst,':sense:current:range 1e-6');
            fprintf(smdata.inst(ind).data.inst,':sense:current:protection 1e-6');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG.K2400_2,'mode') && strcmpi(Inst_CFG.K2400_2.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode curr');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:protection 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:current:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end
        fprintf(smdata.inst(ind).data.inst,':output on');
    catch err
        fprintf(['*ERROR* K2400_2: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== Keithley 2400_3 ==========================
if isfield(Inst_CFG,'K2400_3') && has_transport_fields(Inst_CFG.K2400_3)
    try
        [ind, how] = smloadinst_by_cfg('K2400_Ramp', Inst_CFG.K2400_3, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2400_3';
        smdata.inst(ind).cntrlfn = @smcK2400_Ramp;
        fprintf('[K2400_3] %s\n', how);

        % Safe re-apply
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smaddchannel('K2400_3','V',     'V3',     [-10, 10, Inf, 1]);
        smaddchannel('K2400_3','I',     'I3',     [-Inf, Inf, Inf, 1e6]);
        smaddchannel('K2400_3','I-buf', 'I3-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');

        if isfield(Inst_CFG.K2400_3,'mode') && strcmpi(Inst_CFG.K2400_3.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode volt');
            fprintf(smdata.inst(ind).data.inst,':sense:current:range 1e-6');
            fprintf(smdata.inst(ind).data.inst,':sense:current:protection 1e-6');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG.K2400_3,'mode') && strcmpi(Inst_CFG.K2400_3.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':source:func:mode curr');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:protection 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:current:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end
        fprintf(smdata.inst(ind).data.inst,':output on');
    catch err
        fprintf(['*ERROR* K2400_3: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== Keithley 2450 ==========================
if isfield(Inst_CFG,'K2450') && has_transport_fields(Inst_CFG.K2450)
    try
        [ind, how] = smloadinst_by_cfg('K2450_Ramp', Inst_CFG.K2450, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2450';
        smdata.inst(ind).cntrlfn = @smcK2450_Ramp;
        fprintf('[K2450] %s\n', how);

        % Safe re-apply
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smaddchannel('K2450','Vg',     'Vg',     [-10, 10, Inf, 1]);
        smaddchannel('K2450','Ig',     'Ig',     [-Inf, Inf, Inf, 1e6]);
        smaddchannel('K2450','Ig-buf', 'Ig-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'*cls');

        if isfield(Inst_CFG,'K2450') && isfield(Inst_CFG.K2450,'mode') && strcmpi(Inst_CFG.K2450.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion VOLTage');
            fprintf(smdata.inst(ind).data.inst,':SENSe:CURRent:RANGe 1e-6');
            fprintf(smdata.inst(ind).data.inst,':SOURce:VOLTage:ILIMit 1e-7');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG,'K2450') && isfield(Inst_CFG.K2450,'mode') && strcmpi(Inst_CFG.K2450.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion CURRent');
            fprintf(smdata.inst(ind).data.inst,':SOURce:CURRent:VLIMit 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end

        fprintf(smdata.inst(ind).data.inst,':output on');
        fprintf(smdata.inst(ind).data.inst,':count 1;:trig:cont rest');
    catch err
        fprintf(['*ERROR* K2450: ' err.identifier ': ' err.message '\n']);
    end
end

%====================== Keithley 2450_2 ========================
if isfield(Inst_CFG,'K2450_2') && has_transport_fields(Inst_CFG.K2450_2)
    try
        [ind, how] = smloadinst_by_cfg('K2450_Ramp', Inst_CFG.K2450_2, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name    = 'K2450_2';
        smdata.inst(ind).cntrlfn = @smcK2450_Ramp;
        fprintf('[K2450_2] %s\n', how);

        % Safe re-apply
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smaddchannel('K2450_2','Vg',     'Vbg',     [-10, 10, Inf, 1]);
        smaddchannel('K2450_2','Ig',     'Ibg',     [-Inf, Inf, Inf, 1e6]);
        smaddchannel('K2450_2','Ig-buf', 'Ibg-buf');

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,'*cls');

        if isfield(Inst_CFG,'K2450_2') && isfield(Inst_CFG.K2450_2,'mode') && strcmpi(Inst_CFG.K2450_2.mode,'Voltage')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion VOLTage');
            fprintf(smdata.inst(ind).data.inst,':SENSe:CURRent:RANGe 1e-6');
            fprintf(smdata.inst(ind).data.inst,':SOURce:VOLTage:ILIMit 1e-7');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:voltage:range:auto 1');
        elseif isfield(Inst_CFG,'K2450_2') && isfield(Inst_CFG.K2450_2,'mode') && strcmpi(Inst_CFG.K2450_2.mode,'Current')
            fprintf(smdata.inst(ind).data.inst,':SOURce:FUNCtion CURRent');
            fprintf(smdata.inst(ind).data.inst,':SOURce:CURRent:VLIMit 1');
            fprintf(smdata.inst(ind).data.inst,':sense:voltage:range 10');
            fprintf(smdata.inst(ind).data.inst,':source:delay 0.0');
            fprintf(smdata.inst(ind).data.inst,':source:current:range:auto 1');
        end

        fprintf(smdata.inst(ind).data.inst,':output on');
        fprintf(smdata.inst(ind).data.inst,':count 1;:trig:cont rest');
    catch err
        fprintf(['*ERROR* K2450_2: ' err.identifier ': ' err.message '\n']);
    end
end

%=================== CryoLtd Magnet (Serial/TCP/GPIB/USB) ===================
if isfield(Inst_CFG,'Magnet') && has_transport_fields(Inst_CFG.Magnet)
    try
        [ind, how] = smloadinst_by_cfg('CryoLtd', Inst_CFG.Magnet, Inst_CFG.GPIB);
        % (no special GPIB props needed here)
        smopen(ind);
        smdata.inst(ind).name = 'Magnet';
        fprintf('[Magnet CryoLtd] %s\n', how);

        smaddchannel('Magnet','I','B',[-9,9,Inf,10.167]);    % auto ramp
        smaddchannel('Magnet','M','Bmax',[0,1,Inf,10.167]);  % max field
    catch err
        fprintf(['*ERROR* Magnet (CryoLtd): ' err.identifier ': ' err.message '\n']);
    end
end

%============ Current source (K2400) as small B magnet =========
if isfield(Inst_CFG,'MagnetK2400') && has_transport_fields(Inst_CFG.MagnetK2400)
    try
        [ind, how] = smloadinst_by_cfg('K2400', Inst_CFG.MagnetK2400, Inst_CFG.GPIB);

        % GPIB-only buffer/EOS (before open)
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        smopen(ind);

        smdata.inst(ind).name = 'MagnetSource';
        fprintf('[MagnetSource K2400] %s\n', how);

        % Safe re-apply
        apply_gpib_buffers(smdata.inst(ind).data.inst, how);

        fprintf(smdata.inst(ind).data.inst,'*RST');
        fprintf(smdata.inst(ind).data.inst,':sour:func curr');
        fprintf(smdata.inst(ind).data.inst,':sens:func "volt"');
        fprintf(smdata.inst(ind).data.inst,':outp on');

        smaddchannel('MagnetSource','V','VB',[-Inf Inf Inf 1]); % read-only
        smaddchannel('MagnetSource','I','Bi',[-0.1032,0.1032,0.0005,9.6899]);
        smget('VB');
    catch err
        fprintf(['*ERROR* MagnetSource (K2400): ' err.identifier ': ' err.message '\n']);
    end
end

%=========== B2902A as magnet current source (USB/GPIB/TCP) ====
if isfield(Inst_CFG,'MagnetSource') && has_transport_fields(Inst_CFG.MagnetSource)
    try
        [ind, how] = smloadinst_by_cfg('B2902A', Inst_CFG.MagnetSource, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name    = 'MagnetSource';
        smdata.inst(ind).cntrlfn = @smcB2902A_Alt;
        fprintf('[MagnetSource B2902A] %s\n', how);

        smaddchannel('MagnetSource','V1','VB',[-Inf Inf Inf 1]); % read-only
        smaddchannel('MagnetSource','I1','Bi',[-0.4,0.4,0.002,1/0.1336]);

        fprintf(smdata.inst(ind).data.inst,'*rst');
        fprintf(smdata.inst(ind).data.inst,':source1:function:mode current');
        fprintf(smdata.inst(ind).data.inst,':sense1:voltage:protection 2');
        fprintf(smdata.inst(ind).data.inst,':sense1:voltage:range:auto 2');
        fprintf(smdata.inst(ind).data.inst,':output1 on');
        smget('VB');
    catch err
        fprintf(['*ERROR* MagnetSource (B2902A): ' err.identifier ': ' err.message '\n']);
    end
end

%=================== Triple Current Source (TCS) ===============
if isfield(Inst_CFG,'TCS') && has_transport_fields(Inst_CFG.TCS)
    try
        [ind, how] = smloadinst_by_cfg('TCS', Inst_CFG.TCS, Inst_CFG.GPIB);
        smopen(ind);
        smdata.inst(ind).name = 'TCS';
        fprintf('[TCS] %s\n', how);

        smaddchannel('TCS','SRC1','I_sorp',   [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS','SRC1','I_switch', [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS','SRC2','I_still',  [-Inf, Inf, Inf, 1]);
        smaddchannel('TCS','SRC3','I_mc',     [-Inf, Inf, Inf, 1]);
    catch err
        fprintf(['*ERROR* TCS: ' err.identifier ': ' err.message '\n']);
    end
end

%% Custom Function channels (unchanged)
ind = smloadinst('Function');
smdata.inst(ind).data.dependences={'Vbg','Vtg'};
smdata.inst(ind).data.formula={...
    @(n,E) (n-E)/1.06/2 + 0.08,...
    @(n,E) (n+E)/0.387/2 + 1.4...
    };
smaddchannel('Function', 'VAR1', 'n'); % Density (10^12 cm^-2)
smaddchannel('Function', 'VAR2', 'E'); % Electric field

ind = smloadinst('Function'); smdata.inst(ind).name = 'Fun2';
smdata.inst(ind).data.dependences={'Vdc'};
smdata.inst(ind).data.formula={@(x) 10^x};
smaddchannel('Fun2', 'VAR1', 'log10Vdc');

ind = smloadinst('Function'); smdata.inst(ind).name = 'Fun3';
smdata.inst(ind).data.dependences={'Freq'};
smdata.inst(ind).data.formula={@(x) 10^x};
smaddchannel('Fun3', 'VAR1', 'log10Freq');

%% Basic prints & GUI
smprintinst
smprintchannels

global smaux
smaux.datadir = filedirectory;
if ~isfield(smaux,'run'); smaux.run=100; end
smaux.initialized=1;
sm
smgui_buf

% Escape function
smscan.escapefn.fn = @(x) smset({'dummy','count'},[0,0]);
smscan.escapefn.args = {};

cd(filedirectory)

%% ===================== Helper functions =====================

function tf = has_transport_fields(cfg)
    if isempty(cfg) || ~isstruct(cfg), tf = false; return; end
    tf = false;
    if (isfield(cfg,'usb') && ~isempty(cfg.usb)) || (isfield(cfg,'Usb') && ~isempty(cfg.Usb)) || ...
       (isfield(cfg,'visa') && ~isempty(cfg.visa)) || (isfield(cfg,'Visa') && ~isempty(cfg.Visa)) || ...
       (isfield(cfg,'resource') && ~isempty(cfg.resource)) || (isfield(cfg,'Resource') && ~isempty(cfg.Resource))
        tf = true; return;
    end
    if (isfield(cfg,'gpib_addr') && ~isempty(cfg.gpib_addr)) || (isfield(cfg,'Gpib') && ~isempty(cfg.Gpib))
        tf = true; return;
    end
    if (isfield(cfg,'tcp') && ~isempty(cfg.tcp)) || (isfield(cfg,'Tcp') && ~isempty(cfg.Tcp))
        tf = true; return;
    end
    if (isfield(cfg,'serial') && ~isempty(cfg.serial)) || (isfield(cfg,'Serial') && ~isempty(cfg.Serial)) || ...
       (isfield(cfg,'Com') && ~isempty(cfg.Com))
        tf = true; return;
    end
    % Optional .enable gate
    if isfield(cfg,'enable') && ~isempty(cfg.enable) && logical(cfg.enable)
        % enable alone doesn't say how to connect; keep false
    end
end

function [ind, via] = smloadinst_by_cfg(driverName, cfg, gpibCfg)
% smloadinst_by_cfg  (patched)
% Choose transport strictly from fields in cfg, rewrite the saved
% sminst_<driverName> constructor.fn/args to match that transport,
% then call smloadinst with the correct signature.
%
% Priority: USB/VISA -> GPIB -> TCP -> Serial
%
% cfg supports: Usb/usb/Visa/visa/Resource/resource, Gpib/gpib_addr,
%               Tcp/Port, Serial/Com, optional .enable

    if nargin < 3 || isempty(gpibCfg)
        gpibCfg.board = 'ni';
        gpibCfg.index = 0;
    end

    ind = []; via = '';

    % Respect optional enable gate
    if isfield(cfg,'enable') && ~isempty(cfg.enable) && ~logical(cfg.enable)
        via = 'disabled';
        error('smloadinst_by_cfg:Disabled','Instrument disabled by cfg.enable=false.');
    end

    % -------- VISA / USBTMC (preferred when present) --------
    if hasval(cfg,'usb') || hasval(cfg,'Usb') || hasval(cfg,'visa') || hasval(cfg,'Visa') || hasval(cfg,'resource') || hasval(cfg,'Resource')
        rn = firstval(cfg, {'usb','Usb','visa','Visa','resource','Resource'});
        % Patch sminst to VISA beforehand
        patchedFile = patch_sminst(driverName, 'visa', {rn});
        vendor = pick_visa_vendor(); % 'keysight' | 'agilent' | 'ni'
        ind = smloadinst(patchedFile, [], vendor, rn);
        via = sprintf('VISA (%s)', rn);
        return
    end

    % -------- GPIB --------
    if hasval(cfg,'gpib_addr') || hasval(cfg,'Gpib')
        addr  = [];
        board = gpibCfg.board;
        index = gpibCfg.index;

        if hasval(cfg,'gpib_addr'), addr = cfg.gpib_addr; end
        if hasval(cfg,'Gpib')
            if isstruct(cfg.Gpib)
                if hasval(cfg.Gpib,'board'), board = cfg.Gpib.board; end
                if hasval(cfg.Gpib,'index'), index = cfg.Gpib.index; end
                if hasval(cfg.Gpib,'addr'),  addr  = cfg.Gpib.addr;  end
            else
                addr = cfg.Gpib;
            end
        end

        % Patch sminst to GPIB beforehand
        patchedFile = patch_sminst(driverName, 'gpib', {index, addr});
        ind = smloadinst(patchedFile, [], board, index, addr);
        via = sprintf('GPIB (%s,%d,%s)', char(string(board)), index, char(string(addr)));
        return
    end

    % -------- TCP (RAW socket, e.g. :5025) --------
    if hasval(cfg,'tcp') || hasval(cfg,'Tcp')
        hp = '';
        if hasval(cfg,'tcp'), hp = cfg.tcp; end
        if hasval(cfg,'Tcp'), hp = cfg.Tcp; end
        if hasval(cfg,'Port') && ~contains(string(hp),':')
            hp = sprintf('%s:%d', char(string(hp)), cfg.Port);
        end

        % Patch sminst to tcpclient beforehand
        patchedFile = patch_sminst(driverName, 'tcpclient', {hp});
        ind = smloadinst(patchedFile, [], 'tcpclient', char(string(hp)));
        via = sprintf('TCP (%s)', char(string(hp)));
        return
    end

    % -------- Serial (COMx) --------
    if hasval(cfg,'serial') || hasval(cfg,'Serial') || hasval(cfg,'Com')
        com = '';
        if hasval(cfg,'serial'), com = cfg.serial; end
        if hasval(cfg,'Serial'), com = cfg.Serial; end
        if hasval(cfg,'Com'),    com = cfg.Com;    end
        if isnumeric(com)
            com = sprintf('COM%d', com);
        else
            s = string(com);
            if ~startsWith(upper(s),'COM'), com = char("COM" + s); else, com = char(s); end
        end

        % Patch sminst to serial beforehand
        patchedFile = patch_sminst(driverName, 'serial', {com});
        ind = smloadinst(patchedFile, [], 'serial', com);
        via = sprintf('Serial (%s)', com);
        return
    end

    % -------- Nothing matched --------
    error('smloadinst_by_cfg:NoTransport', ...
          'No transport for "%s". Set one of Usb/Visa/resource, Gpib/gpib_addr, Tcp(+Port), or Serial/Com.', driverName);

% ==== helpers ====

    function tf = hasval(s, f)
        tf = isfield(s,f) && ~isempty(s.(f));
    end

    function v = firstval(s, keys)
        v = '';
        for k = 1:numel(keys)
            if isfield(s, keys{k}) && ~isempty(s.(keys{k}))
                v = s.(keys{k});
                return
            end
        end
    end

    function vendor = pick_visa_vendor()
        % Choose an installed VISA adaptor (order preference).
        vendor = 'ni';
        try
            info = instrhwinfo('visa'); % deprecated but available
            prefs = {'keysight','agilent','ni'};
            for i = 1:numel(prefs)
                if any(strcmpi(info.InstalledAdaptors, prefs{i}))
                    vendor = prefs{i}; break
                end
            end
        catch
            % keep 'ni'
        end
    end

    function patchedPath = patch_sminst(name, kind, argsCell)
        % Load sminst_<name>, rewrite constructor.fn/args, save as
        % a temp "sminst_patched_<name>.mat" and return that path.
        %
        % kind in {'visa','gpib','serial','tcpclient'}
        %
        % NOTE: We do not modify your original file on disk.

        % Locate the original
        cand = {['sminst_', name], ['sminst_', name, '.mat']};
        orig = '';
        for c = 1:numel(cand)
            p = which(cand{c});
            if ~isempty(p), orig = p; break, end
        end
        if isempty(orig)
            % Fall back: smloadinst will try to resolve; but we cannot patch.
            patchedPath = ['sminst_', name];
            warning('patch_sminst:NotFound', 'Could not find sminst_%s on path; proceeding without patch.', name);
            return
        end

        S = load(orig);  % must contain S.constructor and S.inst

        % Rewrite constructor.fn and args
        switch lower(kind)
            case 'visa'
                S.constructor.fn   = @visa;       % legacy VISA object (vendor supplied via smloadinst adaptor arg)
                S.constructor.args = argsCell;    % {'USB0::...::INSTR'}

            case 'gpib'
                S.constructor.fn   = @gpib;       % vendor supplied via smloadinst adaptor arg
                S.constructor.args = argsCell;    % {index, addr}

            case 'serial'
                S.constructor.fn   = @serial;
                S.constructor.args = argsCell;    % {'COMx'}

            case 'tcpclient'
                % smloadinst has a dedicated tcpclient branch,
                % but we still reflect it here for clarity.
                S.constructor.fn   = @tcpclient;
                S.constructor.args = argsCell;    % {'host:port'}

            otherwise
                error('patch_sminst:UnknownKind','Unknown kind "%s".', kind);
        end

        % Save patched copy (temp dir, but name must contain 'sminst_')
        patchedPath = fullfile(tempdir, ['sminst_patched_', name, '.mat']);
        save(patchedPath, '-struct', 'S');
    end
end


function apply_gpib_buffers(obj, via)
% Apply buffer sizes and EOS only when transport is GPIB. Safe to call
% before or after smopen; property sets are try/catch guarded.
    if strncmpi(via, 'GPIB', 4)
        try, set(obj, 'inputbuffersize',  2^18); end  % ~262 kB
        try, set(obj, 'outputbuffersize', 2^10); end  % 1 kB
        if isprop(obj, 'EOSMode')
            try, set(obj, 'eosmode', 'read&write'); end
        end
    end
end
