function [val, rate] = smcK2450_Ramp(ic, val, rate)
% Keithley 2450: Source V / Measure I
% Robust software-stepped sweep with retry & buffer cleanup.
% Channels:
% 1 Vg (R/W) | 2 Ig (R) | 3 VgRange (R/W) | 4 VgRead (R) | 5 Iglimit (R/W)
% 6 Vg-ramp: [start, stop, npts, holdTime] (store sweep plan)
% 7 Ig-buf : run sweep and return npts readings (software stepping)

    if nargin < 1, error('smcK2450_Ramp: ic is required'); end
    if nargin < 2, val  = []; end
    if nargin < 3, rate = []; end

    global smdata;
    io = smdata.inst(ic(1)).data.inst;

    % House-keeping fields
    d = smdata.inst(ic(1)).data;
    if ~isfield(d, 'RampPts'),     d.RampPts   = 0; end
    if ~isfield(d, 'HoldTime'),    d.HoldTime  = 0; end
    if ~isfield(d, 'RampStart'),   d.RampStart = 0; end
    if ~isfield(d, 'RampStop'),    d.RampStop  = 0; end
    smdata.inst(ic(1)).data = d;

    ensure_timeout(io, 180);  % generous IO timeout

    switch ic(2)

        %---------------- Vg (set/read) ----------------%
        case 1
            switch ic(3)
                case 0
                    send(io, ':SOUR:FUNC VOLT');
                    val = qnum(io, ':SOUR:VOLT?');
                case 1
                    assert(~isempty(val), 'K2450/Vg write expects numeric.');
                    send(io, ':SOUR:FUNC VOLT');
                    send(io, sprintf(':SOUR:VOLT %g', val));
                otherwise
                    val = [];
            end

        %---------------- Ig (single read) ----------------%
        case 2
            if ic(3) ~= 0, error('K2450/Ig: write not supported'); end
            send(io, ':SENS:FUNC "CURR"');
            val = qnum(io, ':READ?');  % trigger+return

        %---------------- VgRange ----------------%
        case 3
            switch ic(3)
                case 0
                    auto = qnum(io, ':SOUR:VOLT:RANG:AUTO?');
                    if auto==1, val = 0; else, val = qnum(io, ':SOUR:VOLT:RANG?'); end
                case 1
                    assert(~isempty(val), 'K2450/VgRange expects 0 or numeric.');
                    if val==0
                        send(io, ':SOUR:VOLT:RANG:AUTO 1');
                    else
                        send(io, ':SOUR:VOLT:RANG:AUTO 0');
                        send(io, sprintf(':SOUR:VOLT:RANG %g', val));
                    end
                otherwise
                    error('K2450/VgRange: unsupported op %d', ic(3));
            end

        %---------------- VgRead ----------------%
        case 4
            if ic(3) ~= 0, error('K2450/VgRead: unsupported op'); end
            val = qnum(io, ':SOUR:VOLT?');

        %---------------- Iglimit ----------------%
        case 5
            switch ic(3)
                case 0
                    val = qnum(io, ':SOUR:VOLT:ILIM?');
                case 1
                    assert(~isempty(val), 'K2450/Iglimit expects numeric.');
                    send(io, sprintf(':SOUR:VOLT:ILIM %g', val));
                otherwise
                    error('K2450/Iglimit: unsupported op %d', ic(3));
            end

        %---------------- Vg-ramp: plan the sweep (store only) ----------------%
        case 6
            switch ic(3)
                case 0
                    assert(isvector(val) && numel(val)>=4, 'Vg-ramp needs [start, stop, npts, holdTime]');
                    startV   = val(1);
                    stopV    = val(2);
                    npts     = max(2, round(val(3)));
                    holdTime = max(0, val(4));

                    % Basic setup (fixed, robust defaults)
                    send(io, ':ABOR');
                    send(io, ':SYST:ERR:CLE');         % clear error queue
                    send(io, ':SOUR:FUNC VOLT');
                    send(io, ':SOUR:VOLT:RANG 20');    % covers Â±4 V
                    send(io, ':SENS:FUNC "CURR"');
                    send(io, ':SENS:CURR:RANG 1E-3');  % adjust if needed
                    send(io, ':SENS:CURR:NPLC 0.5');
                    send(io, ':SENS:AZER:STAT OFF');
                    send(io, ':SOUR:DEL 0');           % we control delay in software
                    send(io, ':TRAC:FEED:CONT NEV');   % never feed trace automatically
                    send(io, ':FORM:DATA ASCII');
                    send(io, ':FORM:ELEM READ');       % numeric only for READ?/FETCh?
                    send(io, ':OUTP ON');

                    % Cache the plan for software-stepped sweep
                    d = smdata.inst(ic(1)).data;
                    d.RampPts   = npts;
                    d.HoldTime  = holdTime;
                    d.RampStart = startV;
                    d.RampStop  = stopV;
                    smdata.inst(ic(1)).data = d;

                case 4
                    smdata.inst(ic(1)).data.RampPts = smdata.inst(ic(1)).datadim(ic(2));
                    val = smdata.inst(ic(1)).data.RampPts;

                case 5
                    assert(~isempty(val), 'Vg-ramp op=5 expects val = npts');
                    if isempty(rate), rate = 1; end
                    smdata.inst(ic(1)).datadim(ic(2)) = val;
                    smdata.inst(ic(1)).data.RampPts   = val;
                    smdata.inst(ic(1)).data.HoldTime  = (val>1) * (1/rate);
                    if nargout >= 1, val  = smdata.inst(ic(1)).data.RampPts; end
                    if nargout >= 2, rate = 1/max(smdata.inst(ic(1)).data.HoldTime, eps); end

                otherwise
                    error('K2450/Vg-ramp: unsupported op %d', ic(3));
            end

        %---------------- Ig-buf: software-stepped sweep with retries ----------------%
        case 7
            switch ic(3)
                case 0
                    d = smdata.inst(ic(1)).data;
                    npts = d.RampPts;
                    assert(npts>0, 'K2450/Ig-buf: RampPts not configured via Vg-ramp.');

                    vlist = linspace(d.RampStart, d.RampStop, npts);
                    vals  = nan(1, npts);

                    send(io, ':SOUR:FUNC VOLT');
                    send(io, ':SENS:FUNC "CURR"');

                    for k = 1:npts
                        % Set voltage
                        send(io, sprintf(':SOUR:VOLT %g', vlist(k)));

                        % dwell
                        if d.HoldTime > 0, pause(d.HoldTime); end

                        % robust one-shot read with retries
                        vals(k) = query_num_with_retries(io, ':READ?', 3);
                        % optional compliance fast-fail
                        trip = safe_qnum(io, ':SOUR:VOLT:ILIM:TRIP?');
                        if ~isnan(trip) && trip > 0
                            error('K2450/Ig-buf: compliance tripped at index %d (V=%g)', k, vlist(k));
                        end
                    end
                    val = vals;
                case 3
                    
                case 4
                    smdata.inst(ic(1)).data.RampPts = smdata.inst(ic(1)).datadim(ic(2));
                    val = smdata.inst(ic(1)).data.RampPts;

                case 5
                    assert(~isempty(val), 'Ig-buf op=5 expects val = npts');
                    if isempty(rate), rate = 1; end
                    smdata.inst(ic(1)).datadim(ic(2)) = val;
                    smdata.inst(ic(1)).data.RampPts   = val;
                    smdata.inst(ic(1)).data.HoldTime  = (val>1) * (1/rate);
                    if nargout >= 1, val  = smdata.inst(ic(1)).data.RampPts; end
                    if nargout >= 2, rate = 1/max(smdata.inst(ic(1)).data.HoldTime, eps); end

                otherwise
                    error('K2450/Ig-buf: unsupported op %d', ic(3));
            end

        otherwise
            error('K2450: unknown channel %d', ic(2));
    end
end

% ----------------- helpers -----------------
function ensure_timeout(io, minTimeout)
    try
        if isprop(io, 'Timeout')
            t = get(io, 'Timeout');
            if isempty(t) || ~isscalar(t) || ~isfinite(t) || t < minTimeout
                set(io, 'Timeout', minTimeout);
            end
        end
    catch
    end
end

function send(io, cmd)
    fprintf(io, '%s\n', cmd);
end

function out = qstr(io, cmd)
    % basic query wrapper (single shot)
    out = strtrim(query(io, sprintf('%s\n', cmd)));
end

function out = qnum(io, cmd)
    % basic numeric query
    s = qstr(io, cmd);
    out = str2double(s);
end

function out = safe_qnum(io, cmd)
    % non-throwing numeric query (returns NaN on failure)
    try
        out = qnum(io, cmd);
    catch
        try_flush(io);
        out = NaN;
    end
end

function x = query_num_with_retries(io, cmd, retries)
    % Robust numeric query with buffer flush & small backoff.
    lastErr = '';
    for t = 1:max(1, retries)
        try
            s = qstr(io, cmd);
            x = str2double(s);
            if ~isnan(x)
                return;
            else
                lastErr = 'NaN conversion';
            end
        catch ME
            lastErr = ME.message;
        end
        % flush buffers & small backoff before retry
        try_flush(io);
        pause(0.05);
    end
    error('query_num_with_retries: failed for "%s": %s', cmd, lastErr);
end

function try_flush(io)
    % Try to clear any pending bytes and output buffer without throwing.
    try
        if isprop(io, 'BytesAvailable')
            n = get(io, 'BytesAvailable');
            if ~isempty(n) && n > 0
                fread(io, n, 'uint8'); %#ok<NASGU>
            end
        end
    catch
    end
    try
        if exist('flush','file') == 2
            flush(io);
        end
    catch
    end
end
