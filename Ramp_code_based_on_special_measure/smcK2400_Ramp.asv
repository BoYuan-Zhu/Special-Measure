function [val, rate] = smcK2400_Ramp(ic, val, rate)
%Channels
%1 - 'V' voltage
%2 - 'I' Current
%3 - 'Vcompl' voltage compliance
%4 - 'Icompl' current compliance
%JDSY 12/6/2011 - added ramp channel and changed channel checking to be
%based off numbers
%Yuan 10/3/2015 - removed ramp channel (it's not there!). added compliance
%channel, and realized continuous reading from front panel when idle.
    %Driver for Keithley 2400
    %Last update: Hadar 10-13-2010
    %Error Fixed: LeoZ 8-8-2012

    global smdata;
    %strchan = smdata.inst(ic(1)).channels(ic(2),:);
    switch ic(2) % Channels 
        case 1 %V
            switch ic(3); %Operation: 0 for read, 1 for write

                case 0 %read
                    % Stop continuous updating
                    fprintf(smdata.inst(ic(1)).data.inst,':OUTPut ON');
                    KO = query(smdata.inst(ic(1)).data.inst, ':abort;:arm:count 1;:read?', '%s\n', '%g,%g,%g,%g,%g');
                    val = KO(1);
                    % Resume continuous updating
                    fprintf(smdata.inst(ic(1)).data.inst, ':arm:count infinite;:initiate');

                case 1 %write operation
                    fprintf(smdata.inst(ic(1)).data.inst,':OUTPut ON');
                    cmd = sprintf(':source:volt %g;:initiate', val);
                    fprintf(smdata.inst(ic(1)).data.inst, cmd);
                    pause(0.05);

                otherwise
                    error('K2400 driver: Operation not supported');
            end
        case 2 %I
            switch ic(3); %Operation: 0 for read, 1 for write

                case 0 %read measured current
                    % Stop continuous updating
                    KO = query(smdata.inst(ic(1)).data.inst, ':abort;:arm:count 1;:read?', '%s\n', '%g,%g,%g,%g,%g');
                    val = KO(2);
                    % Resume continuous updating
                    fprintf(smdata.inst(ic(1)).data.inst, ':arm:count infinite;:initiate');

                case 1 %write operation;  
                    cmd = sprintf(':abort;:source:curr %g;:initiate', val);
                    fprintf(smdata.inst(ic(1)).data.inst, cmd);
                    pause(0.05);

                otherwise
                    error('K2400 driver: Operation not supported');
            end
        case 3 %Vcompl
            switch ic(3); %Operation: 0 for read, 1 for write

                case 0 %just read voltage for now
                    val = query(smdata.inst(ic(1)).data.inst, ':abort;:sense:voltage:protection?','%s\n','%g');
                    fprintf(smdata.inst(ic(1)).data.inst, ':initiate');

                case 1 %write operation;  
                    cmd = sprintf(':abort;:sense:voltage:protection %g;:initiate', val);
                    fprintf(smdata.inst(ic(1)).data.inst, cmd);

                otherwise
                    error('K2400 driver: Operation not supported');
            end
        case 4 %Icompl
            switch ic(3); %Operation: 0 for read, 1 for write

                case 0 %just read voltage for now
                    val = query(smdata.inst(ic(1)).data.inst, ':abort;:sense:current:protection?','%s\n','%g');
                    fprintf(smdata.inst(ic(1)).data.inst, ':initiate');

                case 1 %write operation;  
                    cmd = sprintf(':abort;:sense:current:protection %g;:initiate', val);
                    fprintf(smdata.inst(ic(1)).data.inst, cmd);

                otherwise
                    error('K2400 driver: Operation not supported');
            end
    
    
        
                case 5 % Ig-buf (K2400 buffered current helper)
            inst = smdata.inst(ic(1)).data.inst;

            switch ic(3)
                case 3  % one-time configure & arm (prepare buffer & measurement path)
%                     fprintf(inst, '*CLS\n');                    % 清错误/状态队列
%                     fprintf(inst, ':TRIG:CLEar\n');             % 清触发模型  (Trigger subsystem)
                    fprintf(inst, ':ABORt\n');                  % 终止任何进行中的SDM/触发
%                     fprintf(inst, ':TRAC:FEED:CONT NEVer\n');   % 暂停向缓冲写入（确保非active）
                    fprintf(inst, ':TRAC:CLEar\n');             % 现在清空缓冲不会被拒绝
                    
                    fprintf(inst, ':FORM:ELEM CURR\n');         % 只保留电流元素
                    fprintf(inst, ':SOUR:FUNC VOLT\n');         % 源电压-测电流
                    fprintf(inst, ':SOUR:VOLT:RANG 20\n');
                    fprintf(inst, ':SENS:FUNC "CURR"\n');
                    fprintf(inst, ':SENS:CURR:NPLC 1\n');
                    
                    fprintf(inst, ':TRAC:POIN 2500\n');         % 缓冲容量(1..2500)
                    fprintf(inst, ':TRAC:FEED SENS\n');         % 来自测量通道
                    fprintf(inst, ':TRAC:FEED:CONT NEXT\n');    % 每触发一次写下一格
                    fprintf(inst, ':TRIG:COUN 1\n');            % 每次 INIT 采1点
                    % keep simple current-measure setup
                    fprintf(inst, ':SENS:FUNC "CURR"');
                    fprintf(inst, ':SENS:CURR:NPLC 1.000');
                    % do NOT load a trigger model here
                    smdata.inst(ic(1)).data.RampPts = 0;
                    val = [];

                case 2  % single-shot: push one reading into buffer
                    
                    fprintf(inst, ':INIT');    % start; buffer will get one reading due to FEED/NEXT
                    % optional wait-for-complete（一般不需要，因为读取阶段会判断条数）
                    val = [];

                case 0  % read out all available points (safe when none)
                    n = str2double(query(inst, ':TRAC:ACT?','%s\n','%d'));  % number of readings
                    if isempty(n) || isnan(n) || n < 1
                        val = [];
                        return;
                    end
                    raw  = query(inst, sprintf(':TRAC:DATA? %u,%u', 1, n));
                    vals = sscanf(raw, '%g,');   % column vector
                    val  = vals.';               % row vector

                    % optional: clear after read
                    % fprintf(inst, ':TRAC:CLE');
                    smdata.inst(ic(1)).data.RampPts = 0;

                case 4  % planned points from datadim
                    smdata.inst(ic(1)).data.RampPts = smdata.inst(ic(1)).datadim(ic(2));
                    val = smdata.inst(ic(1)).data.RampPts;

                case 5  % set planned points & IO buffer config
                    % if VISA object, set properties while closed
                    fclose(inst); 
                    inst.InputBufferSize = 1e6; 
                    inst.Timeout = 20;     
                    fopen(inst);  

                    smdata.inst(ic(1)).datadim(ic(2)) = val;
                    smdata.inst(ic(1)).data.RampPts   = val;
                 
                    smdata.inst(ic(1)).data.RampTime = (val-1)./rate;
                    

                otherwise
                    error('K2400 driver: Operation not supported for Ig-buf.');
            end


end

